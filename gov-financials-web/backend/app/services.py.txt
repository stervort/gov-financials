import re
import pandas as pd
from sqlalchemy.orm import Session
from .models import TBRow, MappingRule, ConversionEntry
from .templates import STATEMENT_LINES

TB_REQUIRED = ["account","description","balance","type","group","subgroup","subsubgroup"]

def parse_tb_csv(file_bytes: bytes) -> pd.DataFrame:
    df = pd.read_csv(pd.io.common.BytesIO(file_bytes))
    cols = [c.strip().lower() for c in df.columns]
    df.columns = cols
    missing = [c for c in TB_REQUIRED if c not in df.columns]
    if missing:
        raise ValueError(f"Missing required columns: {missing}")
    df["balance"] = pd.to_numeric(df["balance"], errors="coerce").fillna(0.0)
    for c in ["account","description","type","group","subgroup","subsubgroup"]:
        df[c] = df[c].astype(str).fillna("").str.strip()
    return df

def pick_mapping_row(maps: list[MappingRule], account: str, group: str, subgroup: str, subsubgroup: str):
    # precedence: account > subsubgroup > subgroup > group
    for lvl, key in [("account", account), ("subsubgroup", subsubgroup), ("subgroup", subgroup), ("group", group)]:
        if not key:
            continue
        for m in maps:
            if m.source_level == lvl and m.source_key == key:
                return m
    return None

def generate_statement(db: Session, engagement_id: int, target_statement: str):
    tb = db.query(TBRow).filter(TBRow.engagement_id == engagement_id).all()
    maps = db.query(MappingRule).filter(MappingRule.engagement_id == engagement_id).all()

    rows = []
    for r in tb:
        m = pick_mapping_row(maps, r.account, r.group, r.subgroup, r.subsubgroup)
        if m and m.target_statement == target_statement:
            rows.append((m.target_line_code, r.balance * (m.split_pct or 1.0)))
        else:
            # unmapped ignored for now; you can expose a report
            pass

    df = pd.DataFrame(rows, columns=["line_code","amount"]) if rows else pd.DataFrame(columns=["line_code","amount"])
    out = df.groupby("line_code", as_index=False)["amount"].sum()

    # ensure template order
    ordered = []
    for code, label in STATEMENT_LINES.get(target_statement, []):
        amt = float(out.loc[out["line_code"] == code, "amount"].sum()) if not out.empty else 0.0
        ordered.append({"line_code": code, "label": label, "amount": amt})
    return ordered

def apply_conversions(db: Session, engagement_id: int, target_statement: str, base_lines: list[dict]):
    # add conversion lines (statement-line level)
    entries = db.query(ConversionEntry).filter(ConversionEntry.engagement_id == engagement_id).all()
    add = {}
    for e in entries:
        for ln in e.lines:
            if ln.target_statement == target_statement:
                add[ln.target_line_code] = add.get(ln.target_line_code, 0.0) + float(ln.amount)

    for row in base_lines:
        row["amount"] = float(row["amount"]) + float(add.get(row["line_code"], 0.0))
    return base_lines

TOKEN_RE = re.compile(r"\{\{([^}]+)\}\}")

def resolve_tokens(db: Session, engagement_id: int, text: str) -> dict:
    """
    Returns resolved text + a dependency list.
    Supported:
      {{TB.group("Assets")}} -> sum balances where group == Assets
      {{TB.account("1010")}} -> sum balances where account == 1010
      {{FS.<statement>.<line_code>}} -> statement amount (fund or gov-wide)
      Examples:
        {{FS.GF_BS.Cash}}
        {{FS.GW_SNP.CapitalAssetsNet}}
    """
    deps = []

    def tb_sum(**kwargs):
        q = db.query(TBRow).filter(TBRow.engagement_id == engagement_id)
        for k, v in kwargs.items():
            q = q.filter(getattr(TBRow, k) == v)
        return sum([float(x.balance) for x in q.all()])

    def fs_amount(stmt: str, line_code: str):
        lines = generate_statement(db, engagement_id, stmt)
        if stmt.startswith("GW_"):
            lines = apply_conversions(db, engagement_id, stmt, lines)
        for r in lines:
            if r["line_code"] == line_code:
                return float(r["amount"])
        return 0.0

    def repl(match):
        expr = match.group(1).strip()

        # TB.group("X")
        m = re.match(r'TB\.group\("(.+?)"\)', expr)
        if m:
            name = m.group(1)
            val = tb_sum(group=name)
            deps.append({"type":"TB.group","key":name,"value":val})
            return f"{val:,.0f}"

        # TB.account("1010")
        m = re.match(r'TB\.account\("(.+?)"\)', expr)
        if m:
            acct = m.group(1)
            val = tb_sum(account=acct)
            deps.append({"type":"TB.account","key":acct,"value":val})
            return f"{val:,.0f}"

        # FS.STATEMENT.LINECODE
        m = re.match(r'FS\.([A-Z_0-9]+)\.([A-Za-z0-9_]+)', expr)
        if m:
            stmt, line = m.group(1), m.group(2)
            val = fs_amount(stmt, line)
            deps.append({"type":"FS","key":f"{stmt}.{line}","value":val})
            return f"{val:,.0f}"

        return match.group(0)

    resolved = TOKEN_RE.sub(repl, text)
    return {"resolved": resolved, "dependencies": deps}
